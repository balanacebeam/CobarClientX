package io.pddl.jdbc;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;

import io.pddl.executor.ExecuteStatementCallback;
import io.pddl.executor.support.ExecuteStatementWrapper;
import io.pddl.jdbc.adapter.AbstractPreparedStatementAdapter;
import io.pddl.merger.MergeUtils;
import io.pddl.router.support.SQLExecutionUnit;


public final class ShardingPreparedStatement extends AbstractPreparedStatementAdapter {
    
    private final String sql;
    
    private final List<PreparedStatement> cachedRoutedPreparedStatements = new LinkedList<PreparedStatement>();
    
    private Integer autoGeneratedKeys;
    
    private int[] columnIndexes;
    
    private String[] columnNames;
    
    private boolean hasExecuted;
    
    private final List<List<Object>> batchParameters = new ArrayList<>();
    
    public ShardingPreparedStatement(final ShardingConnection shardingConnection, final String sql) throws SQLException {
        this(shardingConnection, sql, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY, ResultSet.HOLD_CURSORS_OVER_COMMIT);
    }
    
    public ShardingPreparedStatement(final ShardingConnection shardingConnection, 
            final String sql, final int resultSetType, final int resultSetConcurrency) throws SQLException {
        this(shardingConnection, sql, resultSetType, resultSetConcurrency, ResultSet.HOLD_CURSORS_OVER_COMMIT);
    }
    
    public ShardingPreparedStatement(final ShardingConnection shardingConnection, 
            final String sql, final int resultSetType, final int resultSetConcurrency, final int resultSetHoldability) throws SQLException {
        super(shardingConnection, resultSetType, resultSetConcurrency, resultSetHoldability);
        this.sql = sql;
    }
    
    public ShardingPreparedStatement(final ShardingConnection shardingConnection, final String sql, final int autoGeneratedKeys) throws SQLException {
        this(shardingConnection, sql);
        this.autoGeneratedKeys = autoGeneratedKeys;
    }
    
    public ShardingPreparedStatement(final ShardingConnection shardingConnection, final String sql, final int[] columnIndexes) throws SQLException {
        this(shardingConnection, sql);
        this.columnIndexes = columnIndexes;
    }
    
    public ShardingPreparedStatement(final ShardingConnection shardingConnection, final String sql, final String[] columnNames) throws SQLException {
        this(shardingConnection, sql);
        this.columnNames = columnNames;
    }
    
    @Override
    public ResultSet executeQuery() throws SQLException {
        hasExecuted = true;
        
        List<ResultSet> result= processor.execute(shardingConnection.getExecuteContext(),generateExecuteStatementWrappers(parameters), new ExecuteStatementCallback<PreparedStatement,ResultSet>(){
			@Override
			public ResultSet execute(String actualSql,PreparedStatement statement) throws SQLException {
				return statement.executeQuery();
			}
    	});
        
        return currentResultSet= MergeUtils.mergeResultSet(result);
    }
    
    @Override
    public int executeUpdate() throws SQLException {
        hasExecuted = true;
        List<Integer> result= processor.execute(shardingConnection.getExecuteContext(),generateExecuteStatementWrappers(parameters), new ExecuteStatementCallback<PreparedStatement,Integer>(){
			@Override
			public Integer execute(String shardingSql,PreparedStatement statement) throws SQLException {
				return statement.executeUpdate();
			}
    	});
        return MergeUtils.mergeIntegerResult(result);
    }
    
    @Override
    public boolean execute() throws SQLException {
        hasExecuted = true;
        List<Boolean> result= processor.execute(shardingConnection.getExecuteContext(),generateExecuteStatementWrappers(parameters), new ExecuteStatementCallback<PreparedStatement,Boolean>(){
			@Override
			public Boolean execute(String shardingSql,PreparedStatement statement) throws SQLException {
				return statement.execute();
			}
    	});
        return result.get(0);
    }
    
    @Override
    public void addBatch() throws SQLException {
        batchParameters.add(new ArrayList<Object>(parameters));
        parameters.clear();
    }
    
    @Override
    public void clearBatch() throws SQLException {
        batchParameters.clear();
    }
    
    @Override
    public int[] executeBatch() throws SQLException {
        hasExecuted = true;
        int[] result = new int[batchParameters.size()];
        int i = 0;
        for (List<Object> each : batchParameters) {
        	List<ExecuteStatementWrapper<PreparedStatement>> routePreparedStatements = generateExecuteStatementWrappers(each);
            List<Integer> tmp= processor.execute(shardingConnection.getExecuteContext(),routePreparedStatements, new ExecuteStatementCallback<PreparedStatement,Integer>(){
    			@Override
    			public Integer execute(String shardingSql,PreparedStatement statement) throws SQLException {
    				return statement.executeUpdate();
    			}
        	});
            result[i++] = MergeUtils.mergeIntegerResult(tmp);;
        }
        return result;
    }
    
    private List<PreparedStatement> getRoutedPreparedStatements() throws SQLException {
        if (!hasExecuted) {
            return Collections.emptyList();
        }
        return cachedRoutedPreparedStatements;
    }
    
    @Override
    public void clearRoutedStatements() throws SQLException {
        getRoutedPreparedStatements().clear();
    }
    
    private List<ExecuteStatementWrapper<PreparedStatement>> generateExecuteStatementWrappers(List<Object> parameters) throws SQLException {
    	List<SQLExecutionUnit> executionUnits = sqlRouter.doRoute(shardingConnection.getExecuteContext(),sql, parameters);
    	List<ExecuteStatementWrapper<PreparedStatement>> result= new ArrayList<ExecuteStatementWrapper<PreparedStatement>>(executionUnits.size());
        for (SQLExecutionUnit each : executionUnits) {
        	Connection conn= shardingConnection.getConnection(each.getDataSourceName());
            PreparedStatement preparedStatement = generatePrepareStatement(conn, each.getShardingSql());
            setParameters(preparedStatement, parameters);
            cachedRoutedPreparedStatements.add(preparedStatement);
            result.add(new ExecuteStatementWrapper<PreparedStatement>(each,preparedStatement));
        }
        return result;
    }
    
    @Override
    public List<PreparedStatement> getRoutedStatements() throws SQLException {
       return getRoutedPreparedStatements();
    }
    
    private PreparedStatement generatePrepareStatement(final Connection conn, final String shardingSql) throws SQLException {
        if (null != autoGeneratedKeys) {
            return conn.prepareStatement(shardingSql, autoGeneratedKeys);
        }
        if (null != columnIndexes) {
            return conn.prepareStatement(shardingSql, columnIndexes);
        }
        if (null != columnNames) {
            return conn.prepareStatement(shardingSql, columnNames);
        }
        if (0 != getResultSetHoldability()) {
            return conn.prepareStatement(shardingSql, getResultSetType(), getResultSetConcurrency(), getResultSetHoldability());
        }
        return conn.prepareStatement(shardingSql, getResultSetType(), getResultSetConcurrency());
    }
    
    private void setParameters(final PreparedStatement preparedStatement, final List<Object> parameters) throws SQLException {
        int i = 1;
        for (Object each : parameters) {
            preparedStatement.setObject(i++, each);
        }
    }
}
