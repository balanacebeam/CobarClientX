package io.pddl.jdbc;

import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Collection;
import java.util.HashSet;
import java.util.Set;

import javax.sql.DataSource;

import io.pddl.datasource.PartitionDataSource;
import io.pddl.executor.ExecuteContext;
import io.pddl.executor.support.ExecuteContextSupport;
import io.pddl.jdbc.adapter.AbstractConnectionAdapter;

public final class ShardingConnection extends AbstractConnectionAdapter {
	
	private ExecuteContext ctx;
	
	private Set<Connection> connections= new HashSet<Connection>();
	
	ShardingDataSource shardingDataSource;
	
    public ShardingConnection(ShardingDataSource shardingDataSource){
    	this.shardingDataSource= shardingDataSource;
    	//创建和ShardingConnection相关联的ExecuteContext上下文对象
    	this.ctx= new ExecuteContextSupport(this,
    			shardingDataSource.shardingDataSourceRepository,
    			shardingDataSource.globalTableRepository,
    			shardingDataSource.logicTableRepository);
    }
    
    @Override
    public DatabaseMetaData getMetaData() throws SQLException {
    	//获取默认数据源进行获取元数据信息
    	//TODO 如果每个数据源中的MetaData不同需要做归并处理，复杂暂时不做处理
    	DataSource ds= shardingDataSource.shardingDataSourceRepository.getDefaultDataSource().getMasterDataSource();
    	Connection conn= ds.getConnection();
    	try{
    		return conn.getMetaData();
    	}finally{
    		conn.close();
    	}
    }
    
    @Override
    public PreparedStatement prepareStatement(final String sql) throws SQLException {
        return new ShardingPreparedStatement(this, sql);
    }
    
    @Override
    public PreparedStatement prepareStatement(final String sql, final int resultSetType, final int resultSetConcurrency) throws SQLException {
        return new ShardingPreparedStatement(this, sql, resultSetType, resultSetConcurrency);
    }
    
    @Override
    public PreparedStatement prepareStatement(final String sql, final int resultSetType, final int resultSetConcurrency, final int resultSetHoldability) throws SQLException {
        return new ShardingPreparedStatement(this, sql, resultSetType, resultSetConcurrency, resultSetHoldability);
    }
    
    @Override
    public PreparedStatement prepareStatement(final String sql, final int autoGeneratedKeys) throws SQLException {
        return new ShardingPreparedStatement(this, sql, autoGeneratedKeys);
    }
    
    @Override
    public PreparedStatement prepareStatement(final String sql, final int[] columnIndexes) throws SQLException {
        return new ShardingPreparedStatement(this, sql, columnIndexes);
    }
    
    @Override
    public PreparedStatement prepareStatement(final String sql, final String[] columnNames) throws SQLException {
        return new ShardingPreparedStatement(this, sql, columnNames);
    }
    
    @Override
    public Statement createStatement() throws SQLException {
        return new ShardingStatement(this);
    }
    
    @Override
    public Statement createStatement(final int resultSetType, final int resultSetConcurrency) throws SQLException {
        return new ShardingStatement(this, resultSetType, resultSetConcurrency);
    }
    
    @Override
    public Statement createStatement(final int resultSetType, final int resultSetConcurrency, final int resultSetHoldability) throws SQLException {
        return new ShardingStatement(this, resultSetType, resultSetConcurrency, resultSetHoldability);
    }

	@Override
	protected Collection<Connection> getConnections() {
		return connections;
	}
	@Override
	public Connection getConnection(String dataSourceName) throws SQLException{
		PartitionDataSource pds= shardingDataSource.shardingDataSourceRepository.getPartitionDataSource(dataSourceName);
		Connection connection = null;
		ExecuteContextSupport ctx= (ExecuteContextSupport)getExecuteContext();
		if(!ctx.isSimplyDQLOperation()){
			if(null!= (connection= ctx.getTranOrUpdateConnection(dataSourceName))){
				return connection;
			}
			connection= pds.getMasterDataSource().getConnection();
			ctx.setTranOrUpdateConnection(dataSourceName,connection);
		}
		else{
			connection= pds.getSlaveDataSource().getConnection();
		}
        connection.setAutoCommit(getAutoCommit());
        connection.setReadOnly(isReadOnly());
		connections.add(connection);
		return connection;
	}
	
	public ExecuteContext getExecuteContext(){
	    return ctx;
	}
    
}
